print(predicted_svm)
r = c(r, predicted_svm)
if (length(r) != last + 1)
{
print('!!!!!!')
}
}
last = length(r)
}
r = c()
last = 0
for (i in 1:1459)
{
prediction = test[i, ]
predicted_svm = predict(svm_model, prediction)
if (TRUE)
{
print(i)
print(predicted_svm)
r = c(r, predicted_svm)
if (length(r) != last + 1)
{
print('!!!!!!')
}
}
last = length(r)
}
for (i in 1:1459)
{
prediction = test[i, ]
predicted_svm = predict(svm_model, prediction)
if (TRUE)
{
print(i)
print(predicted_svm)
r = c(r, predicted_svm)
if (length(r) != last + 1)
{
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
}
}
last = length(r)
}
r = c()
last = 0
for (i in 1:1459)
{
prediction = test[i, ]
predicted_svm = predict(svm_model, prediction)
if (TRUE)
{
print(i)
print(predicted_svm)
r = c(r, predicted_svm)
if (length(r) != last + 1)
{
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
}
}
last = length(r)
}
r = c()
last = 0
for (i in 1:1459)
{
prediction = test[i, ]
predicted_svm = predict(svm_model, prediction)
if (TRUE)
{
print(i)
print(predicted_svm)
r = c(r, predicted_svm)
if (length(r) != last + 1)
{
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
}
}
last = length(r)
}
r = c()
last = 0
for (i in 1:1459)
{
prediction = test[i, ]
predicted_svm = predict(svm_model, prediction)
if (TRUE)
{
print(i)
print(predicted_svm)
r = c(r, predicted_svm)
if (length(r) != last + 1)
{
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
}
}
last = length(r)
}
r = c()
last = 0
for (i in 1:1459)
{
prediction = test[i, ]
predicted_svm = predict(svm_model, prediction)
if (TRUE)
{
print(i)
print(predicted_svm)
r = c(r, predicted_svm)
if (length(r) != last + 1)
{
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
}
}
last = length(r)
}
r = c()
last = 0
for (i in 1:1459)
r = c()
last = 0
for (i in 1:1459)
{
prediction = test[i, ]
predicted_svm = predict(svm_model, prediction)
if (TRUE)
{
#print(i)
#print(predicted_svm)
r = c(r, predicted_svm)
if (length(r) != last + 1)
{
r = c(r, 200000)
}
}
last = length(r)
}
predicted_svm2 = r
predicted = predicted_tree * w1 + predicted_lazy * w2 + predicted_svm2 * w3
p = abs(predicted_svm2 - predicted_lazy)
which.max(p)
f = data.frame(s1 = p)
plot(1:1459, p)
write.table(p, file = "foo.csv", sep = ",", col.names = NA,
qmethod = "double")
write.table(p, file = "foo.csv", sep = ",", col.names = c('Id', 'SalePrice'),
qmethod = "double")
write.table(p, file = "foo.csv", sep = ",", col.names = 'Id',
qmethod = "double")
write.table(p, file = "foo.csv", sep = ",", col.names = c('Id', 'd '),
qmethod = "double")
write.table(p, file = "foo.csv", sep = ",", col.names = c('Id', 'd '),
qmethod = "double", quote = FALSE)
write.table(p, file = "foo.csv", sep = ",", col.names = 'Id',
qmethod = "double", quote = FALSE)
row.names(p) <- row.names(p) + 1460
f = data.frame(s1 = p)
View(f)
row.names(f) <- row.names(f) + 1460
write.table(p, file = "foo.csv", sep = ",", col.names = 'Id',
qmethod = "double", quote = FALSE)
write.table(p,row.names=1:1459, file = "foo.csv", sep = ",", col.names = 'Id',
qmethod = "double", quote = FALSE)
write.table(p,row.names=2:1460, file = "foo.csv", sep = ",", col.names = 'Id',
qmethod = "double", quote = FALSE)
write.table(p,row.names=1461:2919, file = "foo.csv", sep = ",", col.names = 'Id',
qmethod = "double", quote = FALSE)
write.table(predicted,row.names=1461:2919, file = "foo.csv", sep = ",", col.names = 'Id',
qmethod = "double", quote = FALSE)
test_raw = read.csv("./test.csv", header = TRUE)
test = feature_filter_without_saleprice(test_raw)
prediction = test
predicted_tree = predict(tree_model, prediction)
prediction = test
predicted_lazy = predict(lazy_model, prediction)[[1]]  #[[1]] since lazy package implementation returns the result as a list containing a vector as the first element
typeof(2.0)
r = c()
last = 0
for (i in 1:1459)
{
prediction = test[i, ]
predicted_svm = predict(svm_model, prediction)
if (TRUE)
{
#print(i)
#print(predicted_svm)
r = c(r, predicted_svm)
if (length(r) != last + 1)
{
r = c(r, 200000)
}
}
last = length(r)
}
predicted_svm2 = r
predicted = predicted_tree * w1 + predicted_lazy * w2 + predicted_svm2 * w3
p = abs(predicted_svm2 - predicted_lazy)
which.max(p)
f = data.frame(s1 = p)
plot(1:1459, p)
write.table(predicted,row.names=1461:2919, file = "foo.csv", sep = ",", col.names = 'Id',
qmethod = "double", quote = FALSE)
p = abs(predicted_svm2 - predicted_lazy)
which.max(p)
f = data.frame(s1 = p)
row.names(f) <- row.names(f) + 1460
plot(1:1459, p)
version
library(lazy)
library(tree)
library(e1071)
setwd('D:/kaggle')  #TO-MODIFY sets the defaul folder depending on the directory path!!!
source("parameters.R")
source("split-folds.R")
source("feature-filter.R")
evaluate <- function(prediction)
{
return(mean((prediction[,"PredictedPrice"] - prediction[,"RealPrice"])^2))
}
cross_validation <- function(folds, model_flag, param)
{
mse_all = c()
iteration = 1
while (iteration <= length(folds))
{
test = folds[[iteration]]
train = data.frame()
fold_num = 1
while (fold_num <= length(folds))
{
if (fold_num != iteration)
train <- rbind(train, folds[[fold_num]])
fold_num = fold_num + 1
}
model = teach_model(train, model_flag, param)
prediction = test[,1:(ncol(test)-1)]
predicted = predict(model, prediction)
mse = mean((predicted[[1]] - test[,"SalePrice"])^2)
mse_all = c(mse_all, mse)
iteration = iteration + 1
}
return(sqrt(mse))
}
teach_model <- function(train, model_flag, param)
{
if (model_flag == 1)
{
model = tree(SalePrice~., train, control = tree.control(nobs = param[1, 'nobs'], mincut = param[1, 'mincut'], minsize = param[1, 'minsize'], mindev = param[1, 'mindev']))
}
else if (model_flag == 2)
{
model = lazy(SalePrice~., train, control = lazy.control(conIdPar=NULL, linIdPar=param[1, 'linIdPar'], quaIdPar=NULL, distance=c("manhattan","euclidean"), metric=NULL, cmbPar=1, lambda=param[1, 'lambda']))
}
else if (model_flag == 3)
{
model = svm(SalePrice~., train, degree=param[1, 'degree'], nu=param[1, 'nu'], cachesize = 100, tolerance=param[1, 'tolerance'], epsilon=param[1, 'epsilon'])
}
return(model)
}
select_model <- function(train, model_flag, param)
{
folds = split_folds(train)
rmse_all = c()
for (i in 1:nrow(param))
{
rmse = cross_validation(folds, model_flag, param[i, ])
rmse_all = c(rmse_all, rmse)
}
min_index = which.min(rmse_all)
min_value = min(rmse_all)
return(c(min_index, min_value))
}
train_raw = read.csv("./train.csv", header = TRUE)
train = feature_filter(train_raw)
con=lazy.control(conIdPar=NULL, linIdPar=1, quaIdPar=NULL, distance=c("manhattan","euclidean"), metric=NULL, cmbPar=1, lambda=1e+03)
model = lazy(SalePrice~., train,control=con)   #lazy
prediction = train[,1:(ncol(train)-1)]
prediction[,"PredictedPrice"] = predict(model, prediction)
prediction[,"RealPrice"] = train[,"SalePrice"]
vec = prediction[,"PredictedPrice"] - prediction[,"RealPrice"]
mse = mean((prediction[,"PredictedPrice"] - prediction[,"RealPrice"])^2)
rmse = sqrt(mse)
print(rmse)
model = tree(SalePrice~., train, con=tree.control(nobs = 10000, mincut = 1, minsize = 2, mindev = 0))   #lazy
model = svm(SalePrice~., train, degree=10, nu = 0.9, cachesize = 100, tolerance = 0.1, epsilon = 0.5)
prediction = train[,1:(ncol(train)-1)]
prediction[,"PredictedPrice"] = predict(model, prediction)
prediction[,"RealPrice"] = train[,"SalePrice"]
vec = prediction[,"PredictedPrice"] - prediction[,"RealPrice"]
mse = mean((prediction[,"PredictedPrice"] - prediction[,"RealPrice"])^2)
rmse = sqrt(mse)
print(rmse)
model = svm(SalePrice~., train, degree=10, nu = 0.9, cachesize = 100, tolerance = 0.1, epsilon = 0.5)
prediction = train[,1:(ncol(train)-1)]
prediction[,"PredictedPrice"] = predict(model, prediction)
prediction[,"RealPrice"] = train[,"SalePrice"]
vec = prediction[,"PredictedPrice"] - prediction[,"RealPrice"]
mse = mean((prediction[,"PredictedPrice"] - prediction[,"RealPrice"])^2)
rmse = sqrt(mse)
print(rmse)
View(prediction)
train_raw = read.csv("./train.csv", header = TRUE)
train = feature_filter(train_raw)
model = svm(SalePrice~., train, degree=10, nu = 0.9, cachesize = 100, tolerance = 0.1, epsilon = 0.5)
prediction = train[,1:(ncol(train)-1)]
prediction[,"PredictedPrice"] = predict(model, prediction)
prediction[,"RealPrice"] = train[,"SalePrice"]
vec = prediction[,"PredictedPrice"] - prediction[,"RealPrice"]
mse = mean((prediction[,"PredictedPrice"] - prediction[,"RealPrice"])^2)
rmse = sqrt(mse)
print(rmse)
lazy_parameters = get_lazy_parameters()
train_raw = read.csv("./train.csv", header = TRUE)
train = feature_filter(train_raw)
model = tree(SalePrice~., train, con=tree.control(nobs = 10000, mincut = 1, minsize = 2, mindev = 0))   #lazy
prediction = train[,1:(ncol(train)-1)]
prediction[,"PredictedPrice"] = predict(model, prediction)
prediction[,"RealPrice"] = train[,"SalePrice"]
vec = prediction[,"PredictedPrice"] - prediction[,"RealPrice"]
mse = mean((prediction[,"PredictedPrice"] - prediction[,"RealPrice"])^2)
rmse = sqrt(mse)
print(rmse)
prediction = train[,1:(ncol(train)-1)]
prediction[,"PredictedPrice"] = predict(model, prediction)
prediction[,"RealPrice"] = train[,"SalePrice"]
vec = prediction[,"PredictedPrice"] - prediction[,"RealPrice"]
mse = mean((prediction[,"PredictedPrice"] - prediction[,"RealPrice"])^2)
rmse = sqrt(mse)
print(rmse)
View(prediction)
library(lazy)
library(tree)
library(e1071)
setwd('D:/kaggle')  #TO-MODIFY sets the defaul folder depending on the directory path!!!
source("parameters.R")
source("feature-filter.R")
train_raw = read.csv("./train.csv", header = TRUE)
train = feature_filter(train_raw)
tree_conf_id = 6
lazy_conf_id = 2
svm_conf_id = 129
tree_parameters = get_tree_parameters()[tree_conf_id,]
lazy_parameters = get_lazy_parameters()[lazy_conf_id,]
svm_parameters = get_svm_parameters()[svm_conf_id,]
rmse_tree = 81887
rmse_lazy = 41787
rmse_svm = 87749
p1 = 1 / rmse_tree
p2 = 1/ rmse_lazy
p3 = 1/ rmse_svm
s = p1 + p2 + p3
w1 = p1 / s
w2 = p2 / s
w3 = p3 / s
tree_model = teach_model(train, 1, tree_parameters)
lazy_model = teach_model(train, 2, lazy_parameters)
svm_model = teach_model(train, 3, svm_parameters)
prediction = train[,1:(ncol(train)-1)]
predicted_tree = predict(tree_model, prediction)
prediction = train[,1:(ncol(train)-1)]
predicted_lazy = predict(lazy_model, prediction)[[1]]  #[[1]] since lazy package implementation returns the result as a list containing a vector as the first element
prediction = train[,1:(ncol(train)-1)]
predicted_svm = predict(svm_model, prediction)
predicted = predicted_tree * w1 + predicted_lazy * w2 + predicted_svm * w3
mse = mean((predicted - train[,'SalePrice'])^2)
rmse = sqrt(mse)
test_raw = read.csv("./test.csv", header = TRUE)
test = feature_filter_without_saleprice(test_raw)
prediction = test
predicted_tree = predict(tree_model, prediction)
prediction = test
predicted_lazy = predict(lazy_model, prediction)[[1]]  #[[1]] since lazy package implementation returns the result as a list containing a vector as the first element
prediction = test
predicted_tree = predict(tree_model, prediction)
prediction = test
predicted_lazy = predict(lazy_model, prediction)[[1]]  #[[1]] since lazy package implementation returns the result as a list containing a vector as the first element
prediction = test
predicted_svm = predict(svm_model, prediction)
r = c()
last = 0
for (i in 1:1459)
{
prediction = test[i, ]
predicted_svm = predict(svm_model, prediction)
if (TRUE)
{
#print(i)
#print(predicted_svm)
r = c(r, predicted_svm)
if (length(r) != last + 1)
{
print(i)
r = c(r, 200000)
}
}
last = length(r)
}
View(test)
library(lazy)
library(tree)
library(e1071)
setwd('D:/kaggle')  #TO-MODIFY sets the defaul folder depending on the directory path!!!
source("parameters.R")
source("split-folds.R")
source("feature-filter.R")
evaluate <- function(prediction)
{
return(mean((prediction[,"PredictedPrice"] - prediction[,"RealPrice"])^2))
}
cross_validation <- function(folds, model_flag, param)
{
mse_all = c()
iteration = 1
while (iteration <= length(folds))
{
test = folds[[iteration]]
train = data.frame()
fold_num = 1
while (fold_num <= length(folds))
{
if (fold_num != iteration)
train <- rbind(train, folds[[fold_num]])
fold_num = fold_num + 1
}
model = teach_model(train, model_flag, param)
prediction = test[,1:(ncol(test)-1)]
predicted = predict(model, prediction)
mse = mean((predicted[[1]] - test[,"SalePrice"])^2)
mse_all = c(mse_all, mse)
iteration = iteration + 1
}
return(sqrt(mse))
}
teach_model <- function(train, model_flag, param)
{
if (model_flag == 1)
{
model = tree(SalePrice~., train, control = tree.control(nobs = param[1, 'nobs'], mincut = param[1, 'mincut'], minsize = param[1, 'minsize'], mindev = param[1, 'mindev']))
}
else if (model_flag == 2)
{
model = lazy(SalePrice~., train, control = lazy.control(conIdPar=NULL, linIdPar=param[1, 'linIdPar'], quaIdPar=NULL, distance=c("manhattan","euclidean"), metric=NULL, cmbPar=1, lambda=param[1, 'lambda']))
}
else if (model_flag == 3)
{
model = svm(SalePrice~., train, degree=param[1, 'degree'], nu=param[1, 'nu'], cachesize = 100, tolerance=param[1, 'tolerance'], epsilon=param[1, 'epsilon'])
}
return(model)
}
select_model <- function(train, model_flag, param)
{
folds = split_folds(train)
rmse_all = c()
for (i in 1:nrow(param))
{
rmse = cross_validation(folds, model_flag, param[i, ])
rmse_all = c(rmse_all, rmse)
}
min_index = which.min(rmse_all)
min_value = min(rmse_all)
return(c(min_index, min_value))
}
train_raw = read.csv("./train.csv", header = TRUE)
train = feature_filter(train_raw)
View(train)
feature_filter <- function(input) {
result <- subset(input, select=c(MSSubClass,LotArea,LotFrontage,Neighborhood,OverallQual,YearBuilt,
YearRemodAdd,ExterQual,Foundation,
BsmtQual,BsmtFinType1,BsmtFinSF1,TotalBsmtSF,X1stFlrSF,
X2ndFlrSF,GrLivArea,FullBath,KitchenQual,TotRmsAbvGrd,Fireplaces,
FireplaceQu,GarageType,GarageFinish,GarageCars,GarageArea,OpenPorchSF,
SalePrice))
result = replace_na(result)
return(result)
}
feature_filter_without_saleprice <- function(input) {
result <- subset(input, select=c(MSSubClass,LotArea,LotFrontage,Neighborhood,OverallQual,YearBuilt,
YearRemodAdd,ExterQual,Foundation,
BsmtQual,BsmtFinType1,BsmtFinSF1,TotalBsmtSF,X1stFlrSF,
X2ndFlrSF,GrLivArea,FullBath,KitchenQual,TotRmsAbvGrd,Fireplaces,
FireplaceQu,GarageType,GarageFinish,GarageCars,GarageArea,OpenPorchSF))
result = replace_na(result)
return(result)
}
replace_na <- function(data)
{
copy = data.frame(data, stringsAsFactors = FALSE)  #stringsAsFactors is necessary to remove NAs
for (i in 1:nrow(copy))
for (j in 1:ncol(copy))
if (is.na(copy[i,j]))
{
if (typeof(copy[,j]) == typeof(1))
copy[i,j] <- 0
else
copy[i,j] <- 'No'
}
copy = data.frame(data, stringsAsFactors = FALSE)
copy[is.na(copy)] <- 0
return(copy)
}
setwd('D:/kaggle')  #TO-MODIFY sets the defaul folder depending on the directory path!!!
source("parameters.R")
source("split-folds.R")
source("feature-filter.R")
train_raw = read.csv("./train.csv", header = TRUE)
train = feature_filter(train_raw)
View(train)
library(lazy)
library(tree)
library(e1071)
setwd('D:/kaggle')  #TO-MODIFY sets the defaul folder depending on the directory path!!!
source("parameters.R")
version
